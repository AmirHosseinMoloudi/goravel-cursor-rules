---
alwaysApply: true
---

# Goravel Human-Developer & AI-LLM Friendly Code

**CRITICAL**: Always write code that is both human-developer friendly and AI-LLM friendly for optimal collaboration and maintainability.

## Human-Developer Friendly Requirements

### Mandatory Human-Friendly Practices
- **EVERY** function must have clear, descriptive names
- **EVERY** complex logic must be well-commented
- **EVERY** code block must be readable and self-documenting
- **EVERY** error message must be human-readable
- **EVERY** API response must be intuitive
- **EVERY** configuration must be self-explanatory
- **EVERY** test must be understandable

### Prohibited Human-Unfriendly Patterns
```go
// ❌ FORBIDDEN - Cryptic variable names
func processData(d []string, f func(string) bool) []string {
    var r []string
    for _, v := range d {
        if f(v) {
            r = append(r, v)
        }
    }
    return r
}

// ❌ FORBIDDEN - Unclear function names
func calc(a, b int) int {
    return a + b
}

// ❌ FORBIDDEN - Magic numbers without explanation
func validateAge(age int) bool {
    return age >= 18 && age <= 65
}
```

### Required Human-Friendly Patterns
```go
// ✅ REQUIRED - Clear, descriptive function names
func FilterActiveUsers(users []User, isActive func(User) bool) []User {
    var activeUsers []User
    for _, user := range users {
        if isActive(user) {
            activeUsers = append(activeUsers, user)
        }
    }
    return activeUsers
}

// ✅ REQUIRED - Self-documenting variable names
func CalculateUserAge(birthDate time.Time) int {
    currentDate := time.Now()
    age := currentDate.Year() - birthDate.Year()
    
    // Adjust for birthday not yet occurred this year
    if currentDate.YearDay() < birthDate.YearDay() {
        age--
    }
    
    return age
}

// ✅ REQUIRED - Named constants with clear purpose
const (
    MinimumVotingAge = 18
    MaximumRetirementAge = 65
    StandardWorkingHours = 40
)

func ValidateWorkingAge(age int) bool {
    return age >= MinimumVotingAge && age <= MaximumRetirementAge
}
```

## AI-LLM Friendly Requirements

### Mandatory AI-Friendly Practices
- **EVERY** function must have clear input/output types
- **EVERY** complex logic must be broken into smaller functions
- **EVERY** error handling must be explicit and typed
- **EVERY** data structure must be well-defined
- **EVERY** interface must be clearly documented
- **EVERY** pattern must be consistent and predictable
- **EVERY** code must be self-contained and testable

### Prohibited AI-Unfriendly Patterns
```go
// ❌ FORBIDDEN - Ambiguous return types
func GetUserData(id interface{}) interface{} {
    // AI cannot determine return type
    return someComplexData
}

// ❌ FORBIDDEN - Implicit error handling
func ProcessUser(user *User) {
    // AI cannot understand error scenarios
    user.Process()
}

// ❌ FORBIDDEN - Unclear function signatures
func HandleRequest(req, res interface{}) {
    // AI cannot understand parameter types
}
```

### Required AI-Friendly Patterns
```go
// ✅ REQUIRED - Explicit types and clear signatures
func GetUserByID(userID uint) (*User, error) {
    if userID == 0 {
        return nil, errors.New("user ID cannot be zero")
    }
    
    user, err := userRepository.FindByID(userID)
    if err != nil {
        return nil, fmt.Errorf("failed to find user: %w", err)
    }
    
    return user, nil
}

// ✅ REQUIRED - Clear error handling with typed errors
type UserNotFoundError struct {
    UserID uint
}

func (e *UserNotFoundError) Error() string {
    return fmt.Sprintf("user with ID %d not found", e.UserID)
}

func GetUserWithTypedError(userID uint) (*User, error) {
    user, err := userRepository.FindByID(userID)
    if err != nil {
        return nil, &UserNotFoundError{UserID: userID}
    }
    
    return user, nil
}

// ✅ REQUIRED - Well-defined interfaces
type UserRepository interface {
    FindByID(id uint) (*User, error)
    Create(user *User) error
    Update(user *User) error
    Delete(id uint) error
    FindByEmail(email string) (*User, error)
}
```

## Code Documentation Standards

### Function Documentation
```go
// ✅ REQUIRED - Comprehensive function documentation
// CreateUser creates a new user with the provided information.
// It validates the input data, checks for email uniqueness,
// and returns the created user or an error.
//
// Parameters:
//   - name: The user's full name (required, min 2 characters)
//   - email: The user's email address (required, must be valid email format)
//   - age: The user's age (optional, defaults to 0)
//
// Returns:
//   - *User: The created user object with assigned ID
//   - error: Validation error, email conflict, or database error
//
// Example:
//   user, err := CreateUser("John Doe", "john@example.com", 30)
//   if err != nil {
//       log.Printf("Failed to create user: %v", err)
//   }
func CreateUser(name string, email string, age int) (*User, error) {
    // Implementation details...
}
```

### Type Documentation
```go
// ✅ REQUIRED - Clear type documentation
// User represents a user in the system.
// It contains all the essential information about a user
// and provides methods for user-related operations.
type User struct {
    // ID is the unique identifier for the user
    ID uint `json:"id" gorm:"primaryKey"`
    
    // Name is the user's full name
    Name string `json:"name" gorm:"not null" validate:"required,min=2"`
    
    // Email is the user's email address (must be unique)
    Email string `json:"email" gorm:"unique;not null" validate:"required,email"`
    
    // Age is the user's age in years
    Age int `json:"age" gorm:"default:0" validate:"min=0,max=150"`
    
    // IsActive indicates whether the user account is active
    IsActive bool `json:"is_active" gorm:"default:true"`
    
    // CreatedAt is when the user was created
    CreatedAt time.Time `json:"created_at"`
    
    // UpdatedAt is when the user was last updated
    UpdatedAt time.Time `json:"updated_at"`
}

// GetDisplayName returns the user's display name.
// If the user has a name, it returns the name.
// Otherwise, it returns the email address.
func (u *User) GetDisplayName() string {
    if u.Name != "" {
        return u.Name
    }
    return u.Email
}

// IsEligibleForVoting checks if the user is eligible to vote.
// A user is eligible if they are at least 18 years old and active.
func (u *User) IsEligibleForVoting() bool {
    return u.Age >= 18 && u.IsActive
}
```

## Error Handling Standards

### Human-Readable Error Messages
```go
// ✅ REQUIRED - Clear, actionable error messages
func ValidateUserInput(name string, email string, age int) error {
    if name == "" {
        return errors.New("name is required and cannot be empty")
    }
    
    if len(name) < 2 {
        return errors.New("name must be at least 2 characters long")
    }
    
    if email == "" {
        return errors.New("email is required and cannot be empty")
    }
    
    if !isValidEmail(email) {
        return errors.New("email must be in a valid format (e.g., user@example.com)")
    }
    
    if age < 0 {
        return errors.New("age cannot be negative")
    }
    
    if age > 150 {
        return errors.New("age cannot exceed 150 years")
    }
    
    return nil
}

// ✅ REQUIRED - Contextual error information
type ValidationError struct {
    Field   string
    Value   interface{}
    Message string
}

func (e *ValidationError) Error() string {
    return fmt.Sprintf("validation failed for field '%s' with value '%v': %s", 
        e.Field, e.Value, e.Message)
}

func ValidateUserWithContext(name string, email string, age int) error {
    if name == "" {
        return &ValidationError{
            Field:   "name",
            Value:   name,
            Message: "is required and cannot be empty",
        }
    }
    
    if !isValidEmail(email) {
        return &ValidationError{
            Field:   "email",
            Value:   email,
            Message: "must be in a valid format (e.g., user@example.com)",
        }
    }
    
    return nil
}
```

### AI-Friendly Error Handling
```go
// ✅ REQUIRED - Typed errors for AI understanding
type UserError interface {
    error
    UserID() uint
    ErrorType() string
}

type UserNotFoundError struct {
    userID uint
}

func (e *UserNotFoundError) Error() string {
    return fmt.Sprintf("user with ID %d not found", e.userID)
}

func (e *UserNotFoundError) UserID() uint {
    return e.userID
}

func (e *UserNotFoundError) ErrorType() string {
    return "UserNotFound"
}

type UserValidationError struct {
    userID uint
    field  string
    value  interface{}
}

func (e *UserValidationError) Error() string {
    return fmt.Sprintf("validation failed for user %d, field '%s' with value '%v'", 
        e.userID, e.field, e.value)
}

func (e *UserValidationError) UserID() uint {
    return e.userID
}

func (e *UserValidationError) ErrorType() string {
    return "UserValidation"
}
```

## API Design Standards

### Human-Friendly API Responses
```go
// ✅ REQUIRED - Intuitive API response structure
type APIResponse struct {
    Success bool        `json:"success"`
    Message string      `json:"message"`
    Data    interface{} `json:"data,omitempty"`
    Error   *APIError   `json:"error,omitempty"`
    Meta    *APIMeta    `json:"meta,omitempty"`
}

type APIError struct {
    Code    string `json:"code"`
    Message string `json:"message"`
    Details string `json:"details,omitempty"`
}

type APIMeta struct {
    Timestamp time.Time `json:"timestamp"`
    Version   string    `json:"version"`
    RequestID string    `json:"request_id"`
}

// ✅ REQUIRED - Clear success response
func (c *UserController) CreateUser(ctx http.Context) http.Response {
    var input CreateUserRequest
    if err := ctx.Request().Bind(&input); err != nil {
        return ctx.Response().Json(http.StatusBadRequest, APIResponse{
            Success: false,
            Message: "Invalid request data",
            Error: &APIError{
                Code:    "INVALID_INPUT",
                Message: "The request data is invalid",
                Details: err.Error(),
            },
            Meta: &APIMeta{
                Timestamp: time.Now(),
                Version:   "v1",
                RequestID: ctx.Request().Header("X-Request-ID"),
            },
        })
    }
    
    user, err := c.userService.CreateUser(input.Name, input.Email, input.Age)
    if err != nil {
        return ctx.Response().Json(http.StatusInternalServerError, APIResponse{
            Success: false,
            Message: "Failed to create user",
            Error: &APIError{
                Code:    "CREATE_FAILED",
                Message: "Unable to create user due to server error",
                Details: err.Error(),
            },
            Meta: &APIMeta{
                Timestamp: time.Now(),
                Version:   "v1",
                RequestID: ctx.Request().Header("X-Request-ID"),
            },
        })
    }
    
    return ctx.Response().Json(http.StatusCreated, APIResponse{
        Success: true,
        Message: "User created successfully",
        Data:    user,
        Meta: &APIMeta{
            Timestamp: time.Now(),
            Version:   "v1",
            RequestID: ctx.Request().Header("X-Request-ID"),
        },
    })
}
```

### AI-Friendly API Structure
```go
// ✅ REQUIRED - Well-defined request/response types
type CreateUserRequest struct {
    Name  string `json:"name" validate:"required,min=2,max=100"`
    Email string `json:"email" validate:"required,email"`
    Age   int    `json:"age" validate:"min=0,max=150"`
}

type CreateUserResponse struct {
    User    *User      `json:"user"`
    Message string     `json:"message"`
    Created time.Time  `json:"created_at"`
}

type GetUserResponse struct {
    User *User `json:"user"`
}

type ListUsersResponse struct {
    Users      []*User     `json:"users"`
    Pagination *Pagination `json:"pagination"`
}

type Pagination struct {
    Page       int `json:"page"`
    Limit      int `json:"limit"`
    Total      int `json:"total"`
    TotalPages int `json:"total_pages"`
}
```

## Configuration Standards

### Human-Friendly Configuration
```go
// ✅ REQUIRED - Self-documenting configuration
func init() {
    config := facades.Config
    config.Add("app", map[string]interface{}{
        // Application name (used in logs and responses)
        "name": config.Env("APP_NAME", "Goravel Application"),
        
        // Application environment (development, staging, production)
        "env": config.Env("APP_ENV", "production"),
        
        // Debug mode (enables detailed error messages)
        "debug": config.Env("APP_DEBUG", false),
        
        // Application URL (used for generating absolute URLs)
        "url": config.Env("APP_URL", "http://localhost:8080"),
        
        // Application timezone (affects date/time operations)
        "timezone": config.Env("APP_TIMEZONE", "UTC"),
        
        // Application locale (affects language and formatting)
        "locale": config.Env("APP_LOCALE", "en"),
    })
    
    config.Add("database", map[string]interface{}{
        // Default database connection
        "default": config.Env("DB_CONNECTION", "mysql"),
        
        // Database connections configuration
        "connections": map[string]any{
            "mysql": map[string]any{
                "driver":   "mysql",
                "host":     config.Env("DB_HOST", "127.0.0.1"),
                "port":     config.Env("DB_PORT", 3306),
                "database": config.Env("DB_DATABASE", "goravel"),
                "username": config.Env("DB_USERNAME", "root"),
                "password": config.Env("DB_PASSWORD", ""),
                "charset":  config.Env("DB_CHARSET", "utf8mb4"),
                "timezone": config.Env("DB_TIMEZONE", "UTC"),
            },
        },
    })
}
```

### AI-Friendly Configuration
```go
// ✅ REQUIRED - Typed configuration access
type AppConfig struct {
    Name     string `json:"name"`
    Env      string `json:"env"`
    Debug    bool   `json:"debug"`
    URL      string `json:"url"`
    Timezone string `json:"timezone"`
    Locale   string `json:"locale"`
}

type DatabaseConfig struct {
    Default     string                    `json:"default"`
    Connections map[string]ConnectionConfig `json:"connections"`
}

type ConnectionConfig struct {
    Driver   string `json:"driver"`
    Host     string `json:"host"`
    Port     int    `json:"port"`
    Database string `json:"database"`
    Username string `json:"username"`
    Password string `json:"password"`
    Charset  string `json:"charset"`
    Timezone string `json:"timezone"`
}

// ✅ REQUIRED - Type-safe configuration access
func GetAppConfig() (*AppConfig, error) {
    config := &AppConfig{
        Name:     facades.Config().GetString("app.name"),
        Env:      facades.Config().GetString("app.env"),
        Debug:    facades.Config().GetBool("app.debug"),
        URL:      facades.Config().GetString("app.url"),
        Timezone: facades.Config().GetString("app.timezone"),
        Locale:   facades.Config().GetString("app.locale"),
    }
    
    return config, nil
}
```

## Testing Standards

### Human-Readable Tests
```go
// ✅ REQUIRED - Descriptive test names and structure
func TestUserService_CreateUser_WithValidData_ShouldReturnUser(t *testing.T) {
    // Arrange
    userService := NewUserService(mockUserRepository)
    userName := "John Doe"
    userEmail := "john@example.com"
    userAge := 30
    
    // Act
    user, err := userService.CreateUser(userName, userEmail, userAge)
    
    // Assert
    assert.NoError(t, err, "CreateUser should not return an error")
    assert.NotNil(t, user, "CreateUser should return a user")
    assert.Equal(t, userName, user.Name, "User name should match input")
    assert.Equal(t, userEmail, user.Email, "User email should match input")
    assert.Equal(t, userAge, user.Age, "User age should match input")
    assert.True(t, user.IsActive, "New user should be active by default")
}

func TestUserService_CreateUser_WithInvalidEmail_ShouldReturnError(t *testing.T) {
    // Arrange
    userService := NewUserService(mockUserRepository)
    userName := "John Doe"
    invalidEmail := "invalid-email"
    userAge := 30
    
    // Act
    user, err := userService.CreateUser(userName, invalidEmail, userAge)
    
    // Assert
    assert.Error(t, err, "CreateUser should return an error for invalid email")
    assert.Nil(t, user, "CreateUser should not return a user for invalid email")
    assert.Contains(t, err.Error(), "email", "Error message should mention email")
}
```

### AI-Friendly Test Structure
```go
// ✅ REQUIRED - Well-structured test data
type TestCase struct {
    Name        string
    Input       interface{}
    Expected    interface{}
    ShouldError bool
    ErrorType   string
}

func TestUserService_CreateUser_TestCases(t *testing.T) {
    testCases := []TestCase{
        {
            Name: "Valid user data",
            Input: CreateUserInput{
                Name:  "John Doe",
                Email: "john@example.com",
                Age:   30,
            },
            Expected: &User{
                Name:     "John Doe",
                Email:    "john@example.com",
                Age:      30,
                IsActive: true,
            },
            ShouldError: false,
        },
        {
            Name: "Invalid email format",
            Input: CreateUserInput{
                Name:  "John Doe",
                Email: "invalid-email",
                Age:   30,
            },
            Expected:    nil,
            ShouldError: true,
            ErrorType:   "ValidationError",
        },
        {
            Name: "Empty name",
            Input: CreateUserInput{
                Name:  "",
                Email: "john@example.com",
                Age:   30,
            },
            Expected:    nil,
            ShouldError: true,
            ErrorType:   "ValidationError",
        },
    }
    
    for _, tc := range testCases {
        t.Run(tc.Name, func(t *testing.T) {
            // Test implementation
        })
    }
}
```

## Logging Standards

### Human-Friendly Logging
```go
// ✅ REQUIRED - Clear, contextual log messages
func (c *UserController) CreateUser(ctx http.Context) http.Response {
    // Log request start with context
    facades.Log().Info("Creating new user", map[string]any{
        "request_id": ctx.Request().Header("X-Request-ID"),
        "ip_address": ctx.Request().Ip(),
        "user_agent": ctx.Request().Header("User-Agent"),
    })
    
    var input CreateUserRequest
    if err := ctx.Request().Bind(&input); err != nil {
        facades.Log().Warning("Invalid user creation request", map[string]any{
            "request_id": ctx.Request().Header("X-Request-ID"),
            "error":      err.Error(),
            "input":      input,
        })
        
        return ctx.Response().Json(http.StatusBadRequest, APIResponse{
            Success: false,
            Message: "Invalid request data",
            Error: &APIError{
                Code:    "INVALID_INPUT",
                Message: "The request data is invalid",
            },
        })
    }
    
    user, err := c.userService.CreateUser(input.Name, input.Email, input.Age)
    if err != nil {
        facades.Log().Error("Failed to create user", map[string]any{
            "request_id": ctx.Request().Header("X-Request-ID"),
            "error":      err.Error(),
            "input":      input,
        })
        
        return ctx.Response().Json(http.StatusInternalServerError, APIResponse{
            Success: false,
            Message: "Failed to create user",
            Error: &APIError{
                Code:    "CREATE_FAILED",
                Message: "Unable to create user due to server error",
            },
        })
    }
    
    facades.Log().Info("User created successfully", map[string]any{
        "request_id": ctx.Request().Header("X-Request-ID"),
        "user_id":    user.ID,
        "user_email": user.Email,
    })
    
    return ctx.Response().Json(http.StatusCreated, APIResponse{
        Success: true,
        Message: "User created successfully",
        Data:    user,
    })
}
```

### AI-Friendly Logging
```go
// ✅ REQUIRED - Structured logging for AI analysis
type LogEntry struct {
    Level     string                 `json:"level"`
    Message   string                 `json:"message"`
    Timestamp time.Time              `json:"timestamp"`
    Context   map[string]interface{} `json:"context"`
    RequestID string                 `json:"request_id,omitempty"`
    UserID    uint                   `json:"user_id,omitempty"`
    Action    string                 `json:"action,omitempty"`
}

func LogUserAction(level string, message string, context map[string]interface{}) {
    entry := LogEntry{
        Level:     level,
        Message:   message,
        Timestamp: time.Now(),
        Context:   context,
    }
    
    if requestID, ok := context["request_id"].(string); ok {
        entry.RequestID = requestID
    }
    
    if userID, ok := context["user_id"].(uint); ok {
        entry.UserID = userID
    }
    
    if action, ok := context["action"].(string); ok {
        entry.Action = action
    }
    
    facades.Log().Info(message, entry.Context)
}
```

## Best Practices

### Design Principles
- **Clarity First**: Code should be self-explanatory
- **Consistency**: Use consistent patterns throughout
- **Documentation**: Document everything that isn't obvious
- **Error Handling**: Handle errors explicitly and clearly
- **Testing**: Write tests that explain the code's behavior

### Human-Developer Guidelines
- **Readable Code**: Write code that reads like prose
- **Meaningful Names**: Use names that explain intent
- **Small Functions**: Keep functions focused and small
- **Clear Comments**: Comment the "why", not the "what"
- **Consistent Style**: Follow established coding standards

### AI-LLM Guidelines
- **Explicit Types**: Use explicit types everywhere
- **Clear Interfaces**: Define clear, well-documented interfaces
- **Predictable Patterns**: Use consistent, predictable patterns
- **Error Types**: Use typed errors for better understanding
- **Test Coverage**: Maintain comprehensive test coverage

### Collaboration Guidelines
- **Code Reviews**: Focus on readability and maintainability
- **Documentation**: Keep documentation up to date
- **Refactoring**: Refactor for clarity and maintainability
- **Testing**: Write tests that serve as documentation
- **Monitoring**: Monitor code quality continuously